using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class UnityMessageEvent : MonoBehaviour
{
    /************************************************************************
	 * 유니티메시지 이벤트함수
	 * 
	 * 유니티가 보내는 메시지에 반응하는 함수
	 * 포함할 경우 유니티메시지에 반응하지만, 포함하지 않을 경우 무시함
	 * 스크립트는 유니티 엔진이 보내는 메시지에 반응하여 자신의 행동을 정의
	 ************************************************************************/

    private void Awake()
    {
        // 스크립트가 씬에 포함되었을 때 1회 호출되는 함수
        // 스크립트가 비활성화 되어 있는 경우에도 호출됨

        // 역할 : 스크립트가 필요로 하는 초기화 작업 진행
        //		  (게임상황과 무관한 초기화 작업)
        // ex) 데이터 초기화, 컴포넌트 연결

        // 얘만 있으면 초기화가 가능한 상황
        Debug.Log("Awake");
    }

    private void Start()
    {

        // 스크립트가 씬에 처음으로 Update하기 직전에 1회 호출됨
        // 스크립트가 비활성화된 경우 호출되지 않음  -> 오브젝트가 중간에 투입된 상황에도 투입 직후에는 awake가 실행 됨. 

        // 역할 : 스크립트가 필요로 하는 초기화 작업 진행
        //		  (게임상황이 영향을 줄 수 있는 작업)
        // ex) 몬스터의 플레이어 타겟선정

        // 게임 상황을 준비
        Debug.Log("Start");
    }

    //awake : 나 외에 다른 작업이 딱히 볼게 없는 것 먼저 진행
    //start : 모든 오브젝트가 준비된 상황에서 그 다음을 위한 초기화를 진행 

    //그래서 awake는 씬에 포함되어 있으면 무조건 실행하고,
    //start는 게임 직전에 (오브젝트가 다 준비 된 후) 실행을 함.
    
    //실행 순서도 awake가 실행 후, start가 실행 됨. (awake보다 start가 먼저 진행될 수 없음)
    
    


    private void OnEnable()
    {
        // 스크립트가 활성화될 때마다 호출

        // 역할 : 스크립트가 활성화 되었을 때 작업 진행

        // 비활성화된 경우 호출되지 않기 때문에 start는 OnEnable 이후에 실행이 됨.
        Debug.Log("OnEnable");
    }

    private void OnDisable()
    {
        // 스크립트가 비활성화될 때마다 호출

        // 역할 : 스크립트가 비활성화 되었을 때 작업 진행
        Debug.Log("OnDisable");
    }




    /// <summary>
    /// 게임의 프레임마다 호출 -> 연속적인 관리가 필요할 때는 update를 씀 -> 보통 핵심 로직을 구현할 때 씀
    /// </summary>
    private void Update()
    {
        //역할 : 핵심 게임 로직 구현
        Debug.Log("Update");
    }

    /// <summary>
    /// 씬의 모든 게임오브젝트의 Update가 진행된 후 호출
    /// </summary>
    private void LateUpdate()
    {
        // 역할 : 게임프레임의 진행 결과가 필요한 동작이 있는 기능 구현
        // ex) 플레이어의 위치가 결정된 후에 카메라의 위치 설정

        //어떤 씬이 먼저 업데이트 되냐에 따라 참조 결과가 달라질 수 있기 때문에
        //완벽히 참조가 다 되었을 때 업데이트가 필요한 경우에 LateUpdate이벤트를 사용함 
        //예를 들어
        //A와 B가 동일한 위치로 동일한 프레임 시점에 이동하려고 할 때, 먼저 온 update 된 오브젝트가 그 위치를 차지하면 안 돼.
        //이럴 때는 일단 update로 A와 B를 다 이동해놓고, LateUpdate시점에 둘 다 같은 위치에 있으면 둘 다 튕겨나가게 하는 방식 등을 할 때 사용함. 
        Debug.Log("LateUpdate");
    }

    private void FixedUpdate()
    {
        // 유니티의 물리설정 단위시간마다 호출 (기본 1초에 50번)
        // Update와 다르게 프레임당 연산과 단위시간이 일정
        // 단, 게임로직 등, 연산이 많은 작업을 FixedUpdate에 구현하지 않아야 함

        //프레임은 컴퓨터 성능을 탐.  -> 컴퓨터 성능이 떨어지면서 ui상에서 오류가 날 경우를 방지할 수 있음 .(컴퓨터 렉이 걸린 경우에도 잘 작동할 수 있도록...)
        //물리 충돌이 렉 걸린다고 덜 처리하면 안되잖아. 그래서 그럴 때 FiexedUpdate를 많이 사용함. 
        //연산이 많은 작업을 FiexedUpdate에 구현하면, 연산을 잘 못해서 아이템이 막 땅바닥 아래로 쏙 꺼질 수 있음. -> 프레임이 아닌 시간에 따라서 호출되기 때문임. 
        //그래서 보통 연산이 많은 작업은 FiexedUpdate에서 사용하지 않음. 
        //(ex.내가 멍때린다고해서 지구 아래로 꺼지면 안되잖아.!!)

        // 역할 : 성능과 프레임 드랍에 영향을 받지 않아야 하는 작업
        // ex) 물리적 처리
        Debug.Log("FixedUpdate");
    }



    /// <summary>
    ///  스크립트가 삭제되었을 경우 호출 -> 존재 자체가 사라질 때 호출이 됨.
    /// </summary>
    private void OnDestroy()
    {
    // 역할 : 스크립트의 마무리 진행
        Debug.Log("OnDestory");
    }
}